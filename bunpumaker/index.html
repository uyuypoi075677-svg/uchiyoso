<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChartMaker Pro (Final v13 Pattern Scale)</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;800&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=Potta+One&family=Yusei+Magic&family=Zen+Maru+Gothic:wght@500;900&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>

    <!-- Ë¶™ÈöéÂ±§„ÅÆ patterns.js „ÇíË™≠„ÅøËæº„Åø -->
    <script src="../patterns/patterns.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Noto Sans JP"', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: "Noto Sans JP", sans-serif; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 antialiased" x-data="canvasApp()">

    <header class="bg-white border-b border-gray-200 sticky top-0 z-50 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <span class="text-2xl">üìä</span>
                <h1 class="text-xl font-bold text-gray-700">GraphMaker <span class="text-xs text-gray-400 ml-1">chocolat mer</span></h1>
            </div>
            
            <div class="flex items-center gap-2">
                <button @click="reset()" class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-full font-bold shadow-md transition flex items-center gap-1 text-sm">
                    <span>‚Ü∫</span> „É™„Çª„ÉÉ„Éà
                </button>
                <button @click="randomize()" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded-full font-bold shadow-md transition flex items-center gap-1 text-sm">
                    <span>üé≤</span> „É©„É≥„ÉÄ„É†
                </button>
                <button @click="openPreview()" class="bg-gray-700 hover:bg-gray-800 text-white px-4 py-2 rounded-full font-bold shadow-md transition flex items-center gap-1 text-sm">
                    <span>üëÅÔ∏è</span> „Éó„É¨„Éì„É•„Éº
                </button>
                <button @click="downloadImage()" class="bg-pink-500 hover:bg-pink-600 text-white px-5 py-2 rounded-full font-bold shadow-md transition flex items-center gap-2 text-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    ÁîªÂÉè„Çí‰øùÂ≠ò
                </button>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-8 lg:grid lg:grid-cols-12 lg:gap-8">
        
        <div class="lg:col-span-4 space-y-6 mb-8 lg:mb-0">
            <!-- ÊñáÂ≠óË®≠ÂÆö -->
            <div class="bg-white rounded-2xl shadow-sm border border-gray-100 p-5">
                <h2 class="text-lg font-bold mb-4 border-b pb-2">‚úçÔ∏è ÊñáÂ≠ó„Éª„É©„Éô„É´Ë®≠ÂÆö</h2>
                
                <div class="space-y-4">
                    <div><label class="text-xs font-bold text-gray-500">„Çø„Ç§„Éà„É´</label><input type="text" x-model="config.title" @input="draw()" class="w-full border p-2 rounded bg-gray-50"></div>
                    <div class="grid grid-cols-2 gap-2">
                        <div><label class="text-xs font-bold text-gray-400">‰∏ä</label><input type="text" x-model="config.labelTop" @input="draw()" class="w-full border p-2 rounded bg-gray-50"></div>
                        <div><label class="text-xs font-bold text-gray-400">‰∏ã</label><input type="text" x-model="config.labelBottom" @input="draw()" class="w-full border p-2 rounded bg-gray-50"></div>
                        <div><label class="text-xs font-bold text-gray-400">Â∑¶</label><input type="text" x-model="config.labelLeft" @input="draw()" class="w-full border p-2 rounded bg-gray-50"></div>
                        <div><label class="text-xs font-bold text-gray-400">Âè≥</label><input type="text" x-model="config.labelRight" @input="draw()" class="w-full border p-2 rounded bg-gray-50"></div>
                    </div>

                    <div>
                        <label class="text-xs font-bold text-gray-500">„Éï„Ç©„É≥„Éà</label>
                        <select x-model="config.fontFamily" class="w-full border p-2 rounded bg-gray-50 cursor-pointer">
                            <option value="'M PLUS Rounded 1c'">‰∏∏„Ç¥„Ç∑„ÉÉ„ÇØ</option>
                            <option value="'Zen Maru Gothic'">Zen Maru</option>
                            <option value="'Noto Sans JP'">Ê®ôÊ∫ñ„Ç¥„Ç∑„ÉÉ„ÇØ</option>
                            <option value="'Noto Serif JP'">ÊòéÊúù‰Ωì</option>
                            <option value="'Potta One'">„Éù„ÉÉ„Éó‰Ωì</option>
                            <option value="'Yusei Magic'">ÊâãÊõ∏„ÅçÈ¢®</option>
                        </select>
                    </div>

                    <div class="grid grid-cols-2 gap-2">
                        <div><label class="text-xs font-bold text-gray-500">ÊñáÂ≠óËâ≤</label><input type="color" x-model="config.textColor" @input="draw()" class="w-full h-8 rounded cursor-pointer"></div>
                        <div><label class="text-xs font-bold text-gray-500">ÊñáÂ≠óËÉåÊôØ</label><button @click="config.textGlass = !config.textGlass; draw()" class="w-full h-8 rounded text-xs font-bold transition" :class="config.textGlass ? 'bg-pink-500 text-white' : 'bg-gray-200'">Êû†„ÅÇ„Çä</button></div>
                        <div><label class="text-xs font-bold text-gray-500">ÊñáÂ≠óÂΩ±</label><button @click="config.textShadow = !config.textShadow; draw()" class="w-full h-8 rounded text-xs font-bold transition" :class="config.textShadow ? 'bg-pink-500 text-white' : 'bg-gray-200'">ÂΩ±„ÅÇ„Çä</button></div>
                        <div><label class="text-xs font-bold text-gray-500">Êû†„ÅÆ‰∏∏„Åø</label><button @click="config.labelRounded = !config.labelRounded; draw()" class="w-full h-8 rounded text-xs font-bold transition" :class="config.labelRounded ? 'bg-pink-500 text-white' : 'bg-gray-200'">‰∏∏„Åø„ÅÇ„Çä</button></div>
                    </div>
                    <div><label class="text-xs font-bold text-gray-500">„ÇØ„É¨„Ç∏„ÉÉ„Éà</label><input type="text" x-model="config.watermark" @input="draw()" class="w-full border p-2 rounded text-xs"></div>
                </div>
            </div>

            <!-- „Éá„Ç∂„Ç§„É≥Ë®≠ÂÆö -->
            <div class="bg-white rounded-2xl shadow-sm border border-gray-100 p-5">
                <h2 class="text-lg font-bold mb-4 border-b pb-2">üé® „Éá„Ç∂„Ç§„É≥„ÉªËÉåÊôØ</h2>
                <div class="space-y-4">
                    <div class="flex bg-gray-100 p-1 rounded-xl">
                        <button @click="bgType='color'; draw()" :class="bgType==='color'?'bg-white shadow text-pink-600':''" class="flex-1 py-1.5 text-xs font-bold rounded-lg transition">ÂçòËâ≤</button>
                        <button @click="bgType='gradient'; draw()" :class="bgType==='gradient'?'bg-white shadow text-pink-600':''" class="flex-1 py-1.5 text-xs font-bold rounded-lg transition">„Ç∞„É©„Éá</button>
                        <button @click="bgType='pattern'; draw()" :class="bgType==='pattern'?'bg-white shadow text-pink-600':''" class="flex-1 py-1.5 text-xs font-bold rounded-lg transition">ÊüÑ</button>
                        <button @click="bgType='image'; draw()" :class="bgType==='image'?'bg-white shadow text-pink-600':''" class="flex-1 py-1.5 text-xs font-bold rounded-lg transition">ÁîªÂÉè</button>
                    </div>

                    <div x-show="bgType==='pattern'">
                        <input type="color" x-model="config.bgColor" @input="updateThumbnails(); draw()" class="w-full h-8 mb-2 rounded cursor-pointer">
                        <div class="grid grid-cols-5 gap-2 mb-3">
                            <template x-for="(p, idx) in patterns">
                                <button @click="config.patternIndex = idx; draw()" 
                                        class="aspect-square rounded-lg border hover:ring-2 ring-pink-400 relative overflow-hidden"
                                        :class="config.patternIndex === idx ? 'ring-2 ring-pink-500' : ''">
                                    <div class="absolute inset-0 bg-cover bg-center" :style="`background-image: url(${p.thumbUrl});`"></div>
                                </button>
                            </template>
                        </div>
                        <!-- ‚ñº‚ñº‚ñº ÊüÑ„ÅÆ„Çµ„Ç§„Ç∫Ë™øÊï¥„Çπ„É©„Ç§„ÉÄ„Éº (Êñ∞Ë¶èËøΩÂä†) ‚ñº‚ñº‚ñº -->
                        <div class="flex items-center gap-2 p-2 bg-pink-50 rounded-lg border border-pink-100">
                            <span class="text-xs font-bold text-pink-500 whitespace-nowrap">ÊüÑ„ÅÆÂ§ß„Åç„Åï</span>
                            <input type="range" min="0.2" max="3.0" step="0.1" x-model="config.patternScale" @input="draw()" class="w-full h-1.5 bg-pink-200 rounded-lg accent-pink-500 cursor-pointer">
                        </div>
                    </div>

                    <div x-show="bgType==='gradient'" class="space-y-2">
                        <div class="flex gap-2">
                            <input type="color" x-model="config.gradientStart" @input="draw()" class="h-8 w-full rounded cursor-pointer">
                            <span class="text-gray-400">‚Üí</span>
                            <input type="color" x-model="config.gradientEnd" @input="draw()" class="h-8 w-full rounded cursor-pointer">
                        </div>
                        <div class="grid grid-cols-4 gap-2">
                            <template x-for="dir in gradientDirections">
                                <button @click="config.gradientDirection = dir.value; draw()" 
                                        :class="config.gradientDirection === dir.value ? 'ring-2 ring-pink-500 bg-gray-100' : 'border bg-white'"
                                        class="h-8 rounded flex items-center justify-center text-sm" x-text="dir.icon">
                                </button>
                            </template>
                        </div>
                    </div>
                    
                    <div x-show="bgType==='color'">
                        <input type="color" x-model="config.bgColor" @input="draw()" class="w-full h-10 rounded cursor-pointer">
                    </div>

                    <div x-show="bgType==='image'">
                        <input type="file" @change="handleImageUpload" accept="image/*" class="text-xs w-full">
                        <button @click="bgImageObj=null; draw()" class="text-xs text-red-500 mt-2">ÁîªÂÉè„ÇíÂâäÈô§</button>
                    </div>

                    <hr class="border-gray-100">
                    
                    <div class="space-y-3">
                        <div class="flex justify-between items-center"><span class="text-xs font-bold text-gray-500">Ëßí„ÅÆ‰∏∏„Åø</span><input type="range" min="0" max="450" x-model="config.cornerRadius" @input="draw()" class="w-32"></div>
                        
                        <div class="grid grid-cols-2 gap-2">
                            <div class="flex items-center justify-between bg-gray-50 p-2 rounded-lg border">
                                <span class="text-xs text-gray-500">ÊñπÁúºÁ¥ô</span>
                                <button @click="config.gridEnabled = !config.gridEnabled; draw()" :class="config.gridEnabled ? 'bg-pink-500' : 'bg-gray-300'" class="w-8 h-4 rounded-full relative transition"><span :class="config.gridEnabled ? 'translate-x-4' : 'translate-x-0'" class="absolute left-0 top-0 w-4 h-4 bg-white rounded-full shadow transition transform"></span></button>
                            </div>
                            <div class="flex items-center justify-between bg-gray-50 p-2 rounded-lg border">
                                <span class="text-xs text-gray-500">„Ç∞„É©„Éï„ÅÆÂΩ±</span>
                                <button @click="config.graphShadow = !config.graphShadow; draw()" :class="config.graphShadow ? 'bg-pink-500' : 'bg-gray-300'" class="w-8 h-4 rounded-full relative transition"><span :class="config.graphShadow ? 'translate-x-4' : 'translate-x-0'" class="absolute left-0 top-0 w-4 h-4 bg-white rounded-full shadow transition transform"></span></button>
                            </div>
                        </div>

                        <div>
                            <label class="text-xs text-gray-500 block mb-1">ÂçÅÂ≠óÁ∑ö„ÅÆ„Çπ„Çø„Ç§„É´</label>
                            <select x-model="config.crossType" @change="draw()" class="w-full border p-2 rounded-lg text-xs bg-gray-50">
                                <option value="gap">ÈÄèÈÅé</option>
                                <option value="solid">ÂÆüÁ∑ö</option>
                                <option value="dotted">ÁÇπÁ∑ö</option>
                                <option value="stitch">Á∏´„ÅÑÁõÆ</option>
                            </select>
                        </div>
                        <div x-show="config.crossType !== 'gap'" class="flex items-center gap-2 p-2 bg-gray-50 rounded-lg border border-gray-100">
                            <input type="color" x-model="config.crossColor" @input="draw()" class="h-6 w-6 p-0 border-0 rounded cursor-pointer">
                            <input type="range" min="1" max="10" x-model="config.crossWidth" @input="draw()" class="w-20 h-1.5 bg-gray-200 rounded-lg accent-pink-500 cursor-pointer">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="lg:col-span-8">
            <div class="bg-gray-200 rounded-2xl p-4 shadow-inner text-center">
                <span class="text-xs text-gray-500 mb-2 block font-medium">‚ñº „Éó„É¨„Éì„É•„Éº („Åì„Çå„Åå„Åù„ÅÆ„Åæ„Åæ‰øùÂ≠ò„Åï„Çå„Åæ„Åô)</span>
                <canvas x-ref="canvas" width="1200" height="1600" class="w-full h-auto max-w-[600px] mx-auto bg-white shadow-xl rounded-lg"></canvas>
            </div>
        </div>

    </main>

    <div x-show="preview.isOpen" 
         x-transition.opacity 
         class="fixed inset-0 z-50 flex items-center justify-center bg-black/90 p-4" 
         style="display: none;">

        <button @click="preview.isOpen = false" class="absolute top-4 right-4 text-white hover:text-gray-300 z-[100] bg-gray-800/50 rounded-full p-2 transition">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>

        <div class="relative w-full h-full flex flex-col items-center justify-center" @click.self="preview.isOpen = false">
            <div x-show="!preview.src" class="text-white">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
            
            <img x-show="preview.src" 
                 :src="preview.src" 
                 class="max-w-full max-h-[85vh] object-contain shadow-2xl rounded-md" 
                 title="Âè≥„ÇØ„É™„ÉÉ„ÇØ/Èï∑Êäº„Åó„Åß‰øùÂ≠ò"
                 @click.stop>
            
            <p class="text-white/80 mt-4 text-sm font-bold bg-black/50 px-4 py-2 rounded-full">
                ÁîªÂÉè„ÇíÈï∑Êäº„Åó „Åæ„Åü„ÅØ Âè≥„ÇØ„É™„ÉÉ„ÇØ„Åß‰øùÂ≠ò„Åß„Åç„Åæ„Åô
            </p>
        </div>
    </div>

    <script>
        function canvasApp() {
            return {
                bgType: 'pattern',
                bgImageObj: null,
                
                defaults: {
                    title: 'ÊñôÁêÜ‰Ωú„ÇãÂ≠êÔºüÈ£ü„Åπ„Çå„ÇãÂ≠êÔºü',
                    labelTop: 'Ëá™ÂàÜ„Åß‰Ωú„ÇãÔºà„Éó„É≠„É¨„Éô„É´Ôºâ', labelBottom: '‰Ωú„Çå„Å™„ÅÑÔºàÂ£äÊªÖÁöÑÔºâ',
                    labelLeft: 'Â∞èÈ£ü', labelRight: 'Â§ßÈ£ü„ÅÑ',
                    watermark: 'Ôº†chocolat mer',
                    fontFamily: "'M PLUS Rounded 1c'",
                    textColor: '#ec4899', textGlass: true, textShadow: true, labelRounded: true,
                    bgColor: '#fbcfe8',
                    gradientStart: '#fbcfe8', gradientEnd: '#a78bfa', gradientDirection: 'br',
                    patternIndex: 4, 
                    // ‚òÖ„Éá„Éï„Ç©„É´„ÉàÂÄçÁéáÔºö1.0
                    patternScale: 1.0, 
                    cornerRadius: 60,
                    gridEnabled: true,
                    graphShadow: true,
                    crossType: 'gap', 
                    crossColor: '#ec4899',
                    crossWidth: 4,
                },

                config: {},
                preview: { isOpen: false, src: null },

                gradientDirections: [
                    { value: 'r', icon: '‚Üí' }, { value: 'l', icon: '‚Üê' }, { value: 'b', icon: '‚Üì' }, { value: 't', icon: '‚Üë' },
                    { value: 'br', icon: '‚Üò' }, { value: 'tr', icon: '‚Üó' }, { value: 'circle', icon: '‚óé' }, { value: 'conic', icon: '‚óë' },
                ],

                patterns: window.ChartPatternLibrary.config,

                init() {
                    this.reset();
                    this.$watch('config.fontFamily', (val) => {
                        document.fonts.load(`bold 20px ${val}`).then(() => { this.draw(); });
                        setTimeout(() => this.draw(), 100);
                    });
                    document.fonts.ready.then(() => { this.updateThumbnails(); this.draw(); });
                },

                reset() {
                    this.config = JSON.parse(JSON.stringify(this.defaults));
                    this.bgType = 'pattern';
                    this.bgImageObj = null;
                    this.$nextTick(() => { if(this.bgType === 'pattern') this.updateThumbnails(); this.draw(); });
                },

                randomize() {
                    const fonts = ["'M PLUS Rounded 1c'", "'Zen Maru Gothic'", "'Noto Sans JP'", "'Noto Serif JP'", "'Potta One'", "'Yusei Magic'"];
                    const types = ['color', 'gradient', 'pattern'];
                    const directions = ['r', 'l', 'b', 't', 'br', 'tr', 'circle', 'conic'];
                    const crossTypes = ['gap', 'solid', 'dotted', 'stitch'];
                    const pick = arr => arr[Math.floor(Math.random() * arr.length)];
                    const randBool = () => Math.random() > 0.5;
                    const randColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');

                    this.config.fontFamily = pick(fonts);
                    this.config.textColor = randColor();
                    this.config.textGlass = randBool();
                    this.config.textShadow = randBool();
                    this.config.labelRounded = randBool();
                    
                    this.bgType = pick(types);
                    this.config.bgColor = randColor();
                    this.config.gradientStart = randColor();
                    this.config.gradientEnd = randColor();
                    this.config.gradientDirection = pick(directions);
                    this.config.patternIndex = Math.floor(Math.random() * this.patterns.length);
                    // „É©„É≥„ÉÄ„É†ÊôÇ„ÇÇÈÅ©Â∫¶„Å™„Çµ„Ç§„Ç∫„Å´
                    this.config.patternScale = (Math.random() * 1.5 + 0.5).toFixed(1);

                    this.config.cornerRadius = Math.floor(Math.random() * 200);
                    this.config.gridEnabled = randBool();
                    this.config.graphShadow = randBool();
                    
                    this.config.crossType = pick(crossTypes);
                    this.config.crossColor = this.config.textColor; 
                    this.config.crossWidth = Math.floor(Math.random() * 8) + 2;

                    if(this.bgType === 'pattern') this.updateThumbnails();
                    document.fonts.load(`bold 20px ${this.config.fontFamily}`).then(() => { this.draw(); });
                    setTimeout(() => this.draw(), 50);
                },

                updateThumbnails() {
                    const tempC = document.createElement('canvas'); tempC.width = 100; tempC.height = 100;
                    const ctx = tempC.getContext('2d');
                    this.patterns.forEach(p => {
                        ctx.fillStyle = this.config.bgColor; ctx.fillRect(0, 0, 100, 100);
                        // ‚òÖ‚òÖ‚òÖ ‰øÆÊ≠£ÁÇπ: „Çµ„É†„Éç„Ç§„É´‰ΩúÊàêÊôÇ„ÅØÂÄçÁéá„Çí 0.4 „Å´Âõ∫ÂÆö„Åó„Å¶Ë¶ã„ÇÑ„Åô„Åè„Åô„Çã ‚òÖ‚òÖ‚òÖ
                        window.ChartPatternLibrary.draw(ctx, 100, 100, p.canvas, 0.4);
                        p.thumbUrl = tempC.toDataURL();
                    });
                },

                handleImageUpload(e) {
                    const file = e.target.files[0]; if (!file) return;
                    const img = new Image();
                    img.onload = () => { this.bgImageObj = img; this.draw(); };
                    img.src = URL.createObjectURL(file);
                },

                draw() {
                    const canvas = this.$refs.canvas;
                    const ctx = canvas.getContext('2d');
                    const W = canvas.width;
                    const H = canvas.height;

                    ctx.clearRect(0, 0, W, H);

                    if (this.bgType === 'image' && this.bgImageObj) {
                        const scale = Math.max(W / this.bgImageObj.width, H / this.bgImageObj.height);
                        const x = (W - this.bgImageObj.width * scale) / 2;
                        const y = (H - this.bgImageObj.height * scale) / 2;
                        ctx.drawImage(this.bgImageObj, x, y, this.bgImageObj.width * scale, this.bgImageObj.height * scale);
                    } else if (this.bgType === 'gradient') {
                        let grd;
                        const { gradientStart: st, gradientEnd: ed, gradientDirection: dir } = this.config;
                        if (dir === 'r') grd = ctx.createLinearGradient(0, 0, W, 0);
                        else if (dir === 'l') grd = ctx.createLinearGradient(W, 0, 0, 0);
                        else if (dir === 'b') grd = ctx.createLinearGradient(0, 0, 0, H);
                        else if (dir === 't') grd = ctx.createLinearGradient(0, H, 0, 0);
                        else if (dir === 'br') grd = ctx.createLinearGradient(0, 0, W, H);
                        else if (dir === 'tr') grd = ctx.createLinearGradient(0, H, W, 0);
                        else if (dir === 'circle') grd = ctx.createRadialGradient(W/2, H/2, 10, W/2, H/2, W/1.5);
                        else grd = ctx.createLinearGradient(0, 0, W, H);
                        
                        grd.addColorStop(0, st);
                        grd.addColorStop(0.4, st); 
                        grd.addColorStop(1, ed);
                        ctx.fillStyle = grd;
                        ctx.fillRect(0, 0, W, H);
                    } else {
                        ctx.fillStyle = this.config.bgColor;
                        ctx.fillRect(0, 0, W, H);
                        if (this.bgType === 'pattern') {
                            // ‚òÖ‚òÖ‚òÖ ‰øÆÊ≠£ÁÇπ: „É¶„Éº„Ç∂„ÉºÊåáÂÆö„ÅÆÂÄçÁéá (patternScale) „ÇíÈÅ©Áî® ‚òÖ‚òÖ‚òÖ
                            window.ChartPatternLibrary.draw(ctx, W, H, this.patterns[this.config.patternIndex].canvas, this.config.patternScale);
                        }
                    }

                    const chartSize = 980;
                    const chartX = (W - chartSize) / 2;
                    const chartY = (H - chartSize) / 2 + 100;

                    this.drawTextWrapped(ctx, this.config.title, W/2, 70, 70, 1000);

                    const gap = this.config.crossType === 'gap' ? 12 : 0;
                    const halfSize = (chartSize - gap) / 2;
                    const baseSize = this.config.crossType === 'gap' ? halfSize : chartSize;
                    const maxR = baseSize / 2;
                    const cornerR = Math.min(this.config.cornerRadius, maxR); 

                    if (this.config.graphShadow) {
                        ctx.shadowColor = "rgba(0, 0, 0, 0.2)"; ctx.shadowBlur = 30; ctx.shadowOffsetY = 15;
                    } else {
                        ctx.shadowColor = "transparent";
                    }

                    ctx.fillStyle = "#ffffff";
                    ctx.beginPath();
                    if (this.config.crossType === 'gap') {
                        this.traceRoundRectComplex(ctx, chartX, chartY, halfSize, halfSize, {tl: cornerR});
                        this.traceRoundRectComplex(ctx, chartX + halfSize + gap, chartY, halfSize, halfSize, {tr: cornerR});
                        this.traceRoundRectComplex(ctx, chartX, chartY + halfSize + gap, halfSize, halfSize, {bl: cornerR});
                        this.traceRoundRectComplex(ctx, chartX + halfSize + gap, chartY + halfSize + gap, halfSize, halfSize, {br: cornerR});
                    } else {
                        this.traceRoundRect(ctx, chartX, chartY, chartSize, chartSize, cornerR);
                    }
                    ctx.fill(); 
                    ctx.shadowColor = "transparent"; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

                    ctx.save();
                    ctx.beginPath(); 
                    if (this.config.crossType === 'gap') {
                        this.traceRoundRectComplex(ctx, chartX, chartY, halfSize, halfSize, {tl: cornerR});
                        this.traceRoundRectComplex(ctx, chartX + halfSize + gap, chartY, halfSize, halfSize, {tr: cornerR});
                        this.traceRoundRectComplex(ctx, chartX, chartY + halfSize + gap, halfSize, halfSize, {bl: cornerR});
                        this.traceRoundRectComplex(ctx, chartX + halfSize + gap, chartY + halfSize + gap, halfSize, halfSize, {br: cornerR});
                    } else {
                        this.traceRoundRect(ctx, chartX, chartY, chartSize, chartSize, cornerR);
                    }
                    ctx.clip(); 

                    if (this.config.gridEnabled) {
                        this.drawGrid(ctx, chartX, chartY, chartSize);
                    }

                    if (this.config.crossType !== 'gap') {
                        const crossColor = this.config.crossColor;
                        const crossW = this.config.crossWidth;
                        this.drawDottedLine(ctx, chartX, chartY + chartSize/2, chartX + chartSize, chartY + chartSize/2, crossColor, crossW);
                        this.drawDottedLine(ctx, chartX + chartSize/2, chartY, chartX + chartSize/2, chartY + chartSize, crossColor, crossW);
                    }
                    ctx.restore();

                    this.drawText(ctx, this.config.labelTop, W/2, chartY - 52, 40, false);
                    this.drawText(ctx, this.config.labelBottom, W/2, chartY + chartSize + 52, 40, false);
                    this.drawTextVertical(ctx, this.config.labelLeft, chartX - 55, chartY + chartSize/2, 40);
                    this.drawTextVertical(ctx, this.config.labelRight, chartX + chartSize + 55, chartY + chartSize/2, 40);

                    ctx.font = "bold 28px " + this.config.fontFamily;
                    const wmMetrics = ctx.measureText(this.config.watermark);
                    const wmWidth = wmMetrics.width + 80; 
                    const wmX = W - 40; 
                    const wmY = H - 50; 
                    const wmCenterX = wmX - wmWidth/2;

                    this.drawText(ctx, this.config.watermark, wmX, wmY, 28, false, 'right');

                    ctx.fillStyle = this.config.textColor;
                    ctx.font = "bold 24px " + this.config.fontFamily;
                    ctx.textAlign = "center"; 
                    ctx.fillText("„ÉÜ„É≥„Éó„É¨„Éº„Éà‰ΩúÊàê", wmCenterX, H - 90);
                },

                traceRoundRect(ctx, x, y, w, h, r) {
                    const maxR = Math.min(w, h) / 2; r = Math.min(r, maxR);
                    ctx.moveTo(x + r, y);
                    ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r);
                },
                traceRoundRectComplex(ctx, x, y, w, h, radii) {
                    const rTL = radii.tl || 0; const rTR = radii.tr || 0;
                    const rBR = radii.br || 0; const rBL = radii.bl || 0;
                    ctx.moveTo(x + rTL, y);
                    ctx.lineTo(x + w - rTR, y); ctx.quadraticCurveTo(x + w, y, x + w, y + rTR);
                    ctx.lineTo(x + w, y + h - rBR); ctx.quadraticCurveTo(x + w, y + h, x + w - rBR, y + h);
                    ctx.lineTo(x + rBL, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - rBL);
                    ctx.lineTo(x, y + rTL); ctx.quadraticCurveTo(x, y, x + rTL, y);
                },

                drawGrid(ctx, x, y, size) {
                    ctx.strokeStyle = "rgba(200, 200, 200, 0.5)"; ctx.lineWidth = 1; const step = 30;
                    for (let i = x; i <= x + size; i += step) { ctx.beginPath(); ctx.moveTo(i, y); ctx.lineTo(i, y + size); ctx.stroke(); }
                    for (let i = y; i <= y + size; i += step) { ctx.beginPath(); ctx.moveTo(x, i); ctx.lineTo(x + size, i); ctx.stroke(); }
                },

                drawTextWrapped(ctx, text, x, y, fontSize, maxWidth) {
                    if (!text) return;
                    ctx.font = `bold ${fontSize}px ${this.config.fontFamily}`;
                    const chars = text.split(''); const lines = []; let currentLine = '';
                    chars.forEach(char => {
                        if (ctx.measureText(currentLine + char).width > maxWidth && currentLine.length > 0) { lines.push(currentLine); currentLine = char; } else { currentLine += char; }
                    });
                    lines.push(currentLine);
                    const paddingX = 60; const paddingY = 30; const lineHeight = fontSize * 1.3;
                    let maxLineWidth = 0; lines.forEach(line => { const w = ctx.measureText(line).width; if (w > maxLineWidth) maxLineWidth = w; });
                    const bgW = maxLineWidth + paddingX; const bgH = (lineHeight * lines.length) + paddingY - (lineHeight - fontSize);
                    const bgX = x - bgW/2; const bgY = y;
                    
                    if (this.config.textGlass) {
                        if (this.config.textShadow) { ctx.shadowColor = "rgba(0,0,0,0.10)"; ctx.shadowBlur = 15; ctx.shadowOffsetY = 5; }
                        ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
                        ctx.beginPath(); 
                        if (this.config.labelRounded) this.traceRoundRect(ctx, bgX, bgY, bgW, bgH, 20);
                        else ctx.rect(bgX, bgY, bgW, bgH);
                        ctx.fill();
                        ctx.shadowColor = "transparent"; ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 3; ctx.stroke();
                    }
                    ctx.fillStyle = this.config.textColor; ctx.textBaseline = "top"; ctx.textAlign = "center";
                    if (!this.config.textGlass && this.config.textShadow) { ctx.shadowColor = "rgba(255,255,255,0.8)"; ctx.shadowBlur = 0; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; }
                    lines.forEach((line, index) => { ctx.fillText(line, x, bgY + (paddingY/2) + (index * lineHeight)); });
                    ctx.shadowColor = "transparent";
                },
                
                drawText(ctx, text, x, y, fontSize, isTitle, align = 'center') {
                    if (!text) return;
                    ctx.font = `bold ${fontSize}px ${this.config.fontFamily}`;
                    const metrics = ctx.measureText(text); const textW = metrics.width;
                    const paddingX = 40; const paddingY = 20; const bgH = fontSize + paddingY; const bgW = textW + paddingX;
                    let bgX = x - bgW/2; let bgY = y - bgH/2; if (align === 'right') bgX = x - bgW;
                    
                    if (this.config.textGlass) {
                        if (this.config.textShadow) { ctx.shadowColor = "rgba(0,0,0,0.10)"; ctx.shadowBlur = 15; ctx.shadowOffsetY = 5; }
                        ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
                        ctx.beginPath(); 
                        if (this.config.labelRounded) this.traceRoundRect(ctx, bgX, bgY, bgW, bgH, 20);
                        else ctx.rect(bgX, bgY, bgW, bgH);
                        ctx.fill();
                        ctx.shadowColor = "transparent"; ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 3; ctx.stroke();
                    }
                    ctx.fillStyle = this.config.textColor; ctx.textBaseline = "middle"; ctx.textAlign = "center";
                    if (!this.config.textGlass && this.config.textShadow) { ctx.shadowColor = "rgba(255,255,255,0.8)"; ctx.shadowBlur = 0; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; }
                    ctx.fillText(text, bgX + bgW/2, bgY + bgH/2 + (fontSize * 0.05));
                    ctx.shadowColor = "transparent";
                },
                
                drawTextVertical(ctx, text, x, y, fontSize) {
                    if (!text) return;
                    ctx.font = `bold ${fontSize}px ${this.config.fontFamily}`;
                    const charArr = text.split('');
                    const paddingY = 40; const paddingX = 20; const bgW = fontSize + paddingX;
                    const bgH = (fontSize * charArr.length) + paddingY + ((charArr.length-1) * 5);
                    const bgX = x - bgW/2; const bgY = y - bgH/2;
                    
                    if (this.config.textGlass) {
                        if (this.config.textShadow) { ctx.shadowColor = "rgba(0,0,0,0.10)"; ctx.shadowBlur = 15; ctx.shadowOffsetY = 5; }
                        ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
                        ctx.beginPath(); 
                        if (this.config.labelRounded) this.traceRoundRect(ctx, bgX, bgY, bgW, bgH, 20);
                        else ctx.rect(bgX, bgY, bgW, bgH);
                        ctx.fill();
                        ctx.shadowColor = "transparent"; ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 3; ctx.stroke();
                    }
                    ctx.fillStyle = this.config.textColor; ctx.textBaseline = "middle"; ctx.textAlign = "center";
                    if (!this.config.textGlass && this.config.textShadow) { ctx.shadowColor = "rgba(255,255,255,0.8)"; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; }
                    let currentY = bgY + (paddingY/2) + (fontSize/2);
                    charArr.forEach(char => { ctx.fillText(char, x, currentY); currentY += fontSize + 5; });
                    ctx.shadowColor = "transparent";
                },
                
                drawDottedLine(ctx, x1, y1, x2, y2, color, width) {
                    ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap = "round";
                    if (this.config.crossType === 'dotted') { ctx.setLineDash([0, 15]); ctx.lineWidth = width * 2; } 
                    else if (this.config.crossType === 'stitch') { ctx.setLineDash([15, 15]); ctx.lineWidth = width; }
                    else { ctx.setLineDash([]); }
                    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.setLineDash([]);
                },
                
                openPreview() {
                    const canvas = this.$refs.canvas;
                    this.preview.src = canvas.toDataURL('image/png');
                    this.preview.isOpen = true;
                },
                
                downloadImage() {
                    const canvas = this.$refs.canvas;
                    const link = document.createElement('a');
                    link.download = `chart_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }
            }
        }
    </script>
</body>
</html>